<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>修桥过河 · Number Bridge Builder</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      (function () {
        if (window.__NBB_RAN__) return
        const root = document.getElementById('root')
        const css = document.createElement('link')
        css.rel = 'stylesheet'
        css.href = './src/ui/styles.css'
        document.head.appendChild(css)
        const state = {
          levelId: 1,
          gaps: [],
          currentGapIndex: 0,
          bank: [],
          errorsCount: 0,
          usedHints: 0,
          status: 'PLAYING',
          tipText: '',
          roleStep: 0,
          startAt: Date.now(),
          mode: null,
        }
        const MODE_CONFIG = {
          SUM2: { requiredCount: 2, operators: ['+'], label: '两块相加（a+b）' },
          ADD2_SUB2: { requiredCount: 4, operators: ['+','-','-'], label: '四块加减（a+b−c−d）' }
        }
        try {
          const s = localStorage.getItem('number-bridge-settings')
          if (s) {
            const parsed = JSON.parse(s)
            if (parsed.mode && MODE_CONFIG[parsed.mode]) state.mode = parsed.mode
          }
        } catch (e) {}
        function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]] } return a }
        function beep(freq = 800, ms = 120, type = 'sine') {
          const ctx = new (window.AudioContext || window.webkitAudioContext)()
          const osc = ctx.createOscillator()
          const gain = ctx.createGain()
          osc.type = type
          osc.frequency.value = freq
          osc.connect(gain)
          gain.connect(ctx.destination)
          gain.gain.setValueAtTime(0.001, ctx.currentTime)
          gain.gain.exponentialRampToValueAtTime(0.1, ctx.currentTime + 0.02)
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + ms / 1000)
          osc.start()
          setTimeout(() => { osc.stop(); ctx.close() }, ms + 20)
        }
        function evaluateGap(mode, values, target) {
          const cfg = MODE_CONFIG[mode]
          let result = values[0] || 0
          for (let i = 0; i < cfg.operators.length; i++) {
            const op = cfg.operators[i]
            const v = values[i + 1] || 0
            if (op === '+') result += v
            else if (op === '-') result -= v
          }
          const ready = values.length === cfg.requiredCount
          return { result, diff: target - result, ready }
        }
        function genGap(difficulty = 'A', mode = 'SUM2') {
          const target = difficulty === 'A' ? randInt(5, 10) : difficulty === 'B' ? randInt(10, 20) : randInt(20, 100)
          let base = []
          if (mode === 'SUM2') {
            const a = randInt(1, Math.floor(target / 2))
            const b = target - a
            base = [a, b]
          } else {
            const c = randInt(1, Math.floor(target / 2))
            const d = randInt(1, Math.floor(target / 2))
            const sumNeeded = target + c + d
            const a = randInt(Math.max(1, Math.floor(sumNeeded / 3)), Math.floor(sumNeeded / 2))
            const b = sumNeeded - a
            base = [a, b, c, d]
          }
          const noise = []
          const n = difficulty === 'C' ? 10 : 8
          const upper = Math.max(target + 30, 40)
          for (let i = 0; i < n; i++) {
            let v = randInt(1, upper)
            if (base.some(x => Math.abs(v - x) <= 2)) v += randInt(3, 5)
            noise.push(v)
          }
          const bank = shuffle([...base, ...noise]).map((v, i) => ({ id: 'p' + i + '_' + Date.now(), value: v }))
          const required = MODE_CONFIG[mode].requiredCount
          return { id: 'gap_' + Math.random().toString(36).slice(2), target, slots: Array(required).fill(null), bank }
        }
        function genLevel() {
          const m = state.mode || 'SUM2'
          const gaps = m === 'ADD2_SUB2'
            ? [genGap('A', m), genGap('B', m)]
            : [genGap('A', m), genGap('A', m), genGap('B', m)]
          state.gaps = gaps
          state.bank = gaps[0].bank.slice()
          state.currentGapIndex = 0
          state.errorsCount = 0
          state.usedHints = 0
          state.roleStep = 0
          state.status = 'PLAYING'
          state.tipText = ''
          state.startAt = Date.now()
        }
        function renderSelector() {
          root.innerHTML = `
            <div style="padding:24px; display:flex; gap:24px; justify-content:center">
              <button class="mode-card" id="modeSum2" title="${MODE_CONFIG.SUM2.label}">
                <div class="mode-title">${MODE_CONFIG.SUM2.label}</div>
                <div class="mode-illustration">
                  <div class="mode-slot">+</div>
                  <div class="mode-eq">= T</div>
                </div>
              </button>
              <button class="mode-card" id="modeAdd2Sub2" title="${MODE_CONFIG.ADD2_SUB2.label}">
                <div class="mode-title">${MODE_CONFIG.ADD2_SUB2.label}</div>
                <div class="mode-illustration">
                  <div class="mode-slot">+</div><div class="mode-slot">-</div><div class="mode-slot">-</div>
                  <div class="mode-eq">= T</div>
                </div>
              </button>
            </div>
          `
          document.getElementById('modeSum2').onclick = () => {
            state.mode = 'SUM2'
            try {
              const s = localStorage.getItem('number-bridge-settings')
              const parsed = s ? JSON.parse(s) : {}
              parsed.mode = state.mode
              localStorage.setItem('number-bridge-settings', JSON.stringify(parsed))
            } catch (e) {}
            genLevel()
            render()
          }
          document.getElementById('modeAdd2Sub2').onclick = () => {
            state.mode = 'ADD2_SUB2'
            try {
              const s = localStorage.getItem('number-bridge-settings')
              const parsed = s ? JSON.parse(s) : {}
              parsed.mode = state.mode
              localStorage.setItem('number-bridge-settings', JSON.stringify(parsed))
            } catch (e) {}
            genLevel()
            render()
          }
        }
        function render() {
          if (!state.mode) { renderSelector(); return }
          const elapsed = Math.floor((Date.now() - state.startAt) / 1000)
          const gap = state.gaps[state.currentGapIndex]
          const vals = gap.slots.filter(Boolean).map(p => p.value)
          const evalRes = evaluateGap(state.mode, vals, gap.target)
          const remaining = evalRes.diff
          root.innerHTML = `
            <div class="game">
              <div class="hud">
                <div>Level ${state.levelId} · Gap ${state.currentGapIndex + 1}/${state.gaps.length}</div>
                <div>Errors ${state.errorsCount}</div>
                <div>Time ${elapsed}s</div>
                <div class="controls-bar">
                  <button class="btn secondary" id="btnChooseMode">选择玩法</button>
                  <button class="btn" id="btnHint">提示</button>
                  <button class="btn secondary" id="btnReset">重来</button>
                </div>
                <div class="feedback">${state.tipText || (vals.length ? '当前值 ' + evalRes.result + '，还差 ' + remaining : '把桥板拖到槽位上')}</div>
              </div>
              <div class="river">
                <div class="role ${state.roleStep ? 'move' : ''}"></div>
                <div class="gaps ${state.mode === 'ADD2_SUB2' ? 'wide' : ''}">
                  ${state.gaps.map((g, i) => `
                    <div id="${g.id}" class="gap ${g.slots.length > 3 ? 'gap-4' : ''}" style="opacity:${i < state.currentGapIndex ? 0.5 : 1}">
                      <div class="target">${g.target}</div>
                      <div class="slots expr ${MODE_CONFIG[state.mode].requiredCount > 3 ? 'tight' : ''}">
                        ${g.slots.map((p, si) => `
                          <div class="slot ${p ? 'filled' : ''} ${i === state.currentGapIndex ? 'highlight' : ''}" data-si="${si}" data-gi="${i}">${p ? p.value : ''}</div>
                          ${si < MODE_CONFIG[state.mode].operators.length ? `<div class="op">${MODE_CONFIG[state.mode].operators[si]}</div>` : ''}
                        `).join('')}
                        <div class="eq">=</div>
                        <div class="mode-eq">T</div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
              <div class="bank">
                ${state.bank.map((p, i) => `
                  <div class="plank" data-idx="${i}">${p.value}</div>
                `).join('')}
              </div>
            </div>
          `
          bindEvents()
        }
        function checkGap() {
          const gap = state.gaps[state.currentGapIndex]
          const filled = gap.slots.filter(Boolean)
          if (filled.length < gap.slots.length) return
          state.status = 'CHECKING'
          const vals = filled.map(p => p.value)
          const evalRes = evaluateGap(state.mode, vals, gap.target)
          if (evalRes.ready && evalRes.diff === 0) {
            beep(900, 120, 'triangle')
            state.roleStep++
            (function addRipple() {
              const river = document.querySelector('.river')
              const gapEl = document.getElementById(gap.id)
              if (!river || !gapEl) return
              const rr = river.getBoundingClientRect()
              const gr = gapEl.getBoundingClientRect()
              const x = gr.left + gr.width / 2 - rr.left
              const y = gr.bottom - rr.top + 6
              const el = document.createElement('div')
              el.className = 'ripple'
              el.style.left = x + 'px'
              el.style.top = y + 'px'
              river.appendChild(el)
              setTimeout(() => el.remove(), 950)
            })()
            setTimeout(() => {
              if (state.currentGapIndex === state.gaps.length - 1) {
                alert('过关！')
                state.levelId++
                genLevel()
                render()
              } else {
                state.currentGapIndex++
                const next = state.gaps[state.currentGapIndex]
                state.bank = next.bank.slice()
                state.status = 'PLAYING'
                render()
              }
            }, 400)
          } else {
            beep(180, 180, 'sawtooth')
            state.errorsCount++
            const gapEl = document.getElementById(gap.id)
            if (gapEl) {
              gapEl.classList.add('fail')
              setTimeout(() => gapEl.classList.remove('fail'), 500)
            }
            for (let i = 0; i < gap.slots.length; i++) {
              const p = gap.slots[i]
              if (p) { state.bank.push(p); gap.slots[i] = null }
            }
            state.status = 'PLAYING'
            render()
          }
        }
        let dragging = null
        function bindEvents() {
          document.getElementById('btnReset').onclick = () => { genLevel(); render() }
          document.getElementById('btnChooseMode').onclick = () => {
            state.mode = null
            renderSelector()
          }
          document.getElementById('btnHint').onclick = () => {
            const gap = state.gaps[state.currentGapIndex]
            const filledCount = gap.slots.filter(Boolean).length
            const cfg = MODE_CONFIG[state.mode]
            if (filledCount >= cfg.requiredCount) return
            const nextOp = cfg.operators[filledCount] || '+'
            let bestIdx = -1, bestScore = Infinity
            for (let i = 0; i < state.bank.length; i++) {
              const vals = gap.slots.filter(Boolean).map(p => p.value)
              const v = state.bank[i].value
              const testVals = vals.slice()
              if (filledCount === 0) testVals.push(v)
              else {
                // apply operator preview
                const interim = evaluateGap(state.mode, vals, gap.target).result
                const resultPreview = nextOp === '+' ? interim + v : interim - v
                const diffPreview = Math.abs(gap.target - resultPreview)
                if (diffPreview < bestScore) { bestScore = diffPreview; bestIdx = i }
                continue
              }
              const diffPreview = Math.abs(evaluateGap(state.mode, testVals, gap.target).diff)
              if (diffPreview < bestScore) { bestScore = diffPreview; bestIdx = i }
            }
            const els = document.querySelectorAll('.plank')
            if (bestIdx !== -1 && els[bestIdx]) {
              els[bestIdx].style.boxShadow = '0 0 18px #10b981'
              setTimeout(() => els[bestIdx].style.boxShadow = '', 600)
            }
          }
          document.querySelectorAll('.plank').forEach(el => {
            el.onpointerdown = (e) => {
              const idx = +el.dataset.idx
              const p = state.bank[idx]
              dragging = { idx, p, startX: e.clientX, startY: e.clientY, el }
              el.classList.add('dragging')
              el.setPointerCapture(e.pointerId)
              beep(700, 80, 'square')
            }
            el.onpointermove = (e) => {
              if (!dragging || dragging.el !== el) return
              const dx = e.clientX - dragging.startX
              const dy = e.clientY - dragging.startY
              el.style.transform = `translate(${dx}px, ${dy}px) scale(1.08)`
            }
            el.onpointerup = (e) => {
              if (!dragging || dragging.el !== el) return
              el.classList.remove('dragging')
              el.style.transform = ''
              const gap = state.gaps[state.currentGapIndex]
              const gapEl = document.getElementById(gap.id)
              const r = gapEl.getBoundingClientRect()
              if (e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom) {
                const slotIndex = gap.slots.findIndex(s => s === null)
                if (slotIndex !== -1) {
                  gap.slots[slotIndex] = dragging.p
                  state.bank.splice(dragging.idx, 1)
                  render()
                  checkGap()
                }
              }
              dragging = null
            }
            el.onclick = () => {
              const t = state.gaps[state.currentGapIndex].target
              state.tipText = '和 ' + (t - state.bank[+el.dataset.idx].value) + ' 能凑 ' + t
              render()
              setTimeout(() => { state.tipText = ''; render() }, 800)
            }
          })
          document.querySelectorAll('.slot').forEach(el => {
            el.onclick = () => {
              const gi = +el.dataset.gi, si = +el.dataset.si
              const gap = state.gaps[gi]
              const p = gap.slots[si]
              if (p && state.status !== 'CHECKING') {
                state.bank.push(p)
                gap.slots[si] = null
                render()
              }
            }
          })
        }
        genLevel()
        render()
      })()
    </script>
  </body>
  </html>
