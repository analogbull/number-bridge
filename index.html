<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>修桥过河 · Number Bridge Builder</title>
    <style>
      :root {
        --bg: #0d1420;
        --panel: #111827;
        --text: #e5eef7;
        --accent: #3ddbf2;
        --accent-strong: #19b6d4;
        --good: #ffd34d;
        --bad: #ff5757;
        --gap: #adb5bd;
        --metal1: #cfd6dd;
        --metal2: #a9b1b8;
        --metal3: #8c949b;
        --led-bg: #0b1220;
        --led-pixel: #2ee1ff;
        --rivet-size: 12px;
        --shine-duration: 1.2s;

        /* Responsive Sizes (Desktop Default) */
        --plank-size: 90px;
        --slot-size: 80px;
        --gap-width: 220px;
        --gap-height: 140px;
        --gap4-width: 520px;
        --font-plank: 30px;
        --font-target: 30px;
        --slot-margin: 12px;
      }

      @media (max-width: 600px) {
        :root {
          --plank-size: 60px;
          --slot-size: 50px;
          --gap-width: 160px;
          --gap-height: 110px;
          --gap4-width: 96vw; /* Full width on mobile */
          --font-plank: 22px;
          --font-target: 24px;
          --slot-margin: 6px;
          --rivet-size: 8px;
        }
      }
      * { box-sizing: border-box; }
      body, html, #root { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, sans-serif; }
      .app { display: flex; flex-direction: column; height: 100%; }
      .header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: var(--panel); }
      .brand { font-weight: 700; }
      .controls select, .controls button { margin-left: 8px; padding: 6px 10px; }
      .mode-card {
        padding: 16px; border-radius: 12px; border: 2px solid #7b8792; background: linear-gradient(180deg, #121a29, #0f172a);
        color: var(--text); cursor: pointer; width: 280px; box-shadow: 0 6px 12px rgba(0,0,0,0.35);
      }
      .mode-card[aria-pressed="true"] { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(61,219,242,0.5); }
      .mode-title { font-weight: 900; margin-bottom: 12px; }
      .mode-illustration { display: flex; align-items: center; gap: 8px; }
      .mode-slot { width: 46px; height: 46px; border-radius: 10px; border: 2px solid #7b8792; display: flex; align-items: center; justify-content: center;
        background: linear-gradient(90deg, var(--metal1), var(--metal2) 45%, var(--metal3)); color: #0c1a26; font-weight: 900; }
      .mode-eq { font-weight: 900; color: #bfefff; }
      .hud { display: flex; gap: 12px; align-items: center; padding: 6px 12px; background: linear-gradient(180deg, #0e1624, #0b1220); border-bottom: 1px solid #1f2937; flex-wrap: wrap; }
      .game { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
      .river { flex: 1; display: flex; align-items: center; justify-content: center; background: linear-gradient(90deg, #0ea5e9 0%, #1d4ed8 100%); position: relative; overflow: hidden; }
      .river::before {
        content: "";
        position: absolute; inset: 0;
        background-image:
          repeating-linear-gradient(120deg, rgba(255,255,255,0.06) 0px, rgba(255,255,255,0.06) 2px, rgba(0,0,0,0.04) 4px, rgba(0,0,0,0.02) 6px);
        background-size: 240px 100%;
        mix-blend-mode: overlay;
        opacity: 0.18;
        animation: waterDrift var(--flow-speed-texture, 10s) linear infinite;
        pointer-events: none;
      }
      @keyframes waterDrift {
        0%   { background-position: 0 0; }
        100% { background-position: 240px 0; }
      }
      .water-base {
        position: absolute; inset: 0;
        background: linear-gradient(110deg, rgba(14,165,233,0.3), rgba(29,78,216,0.45)), linear-gradient(90deg, rgba(14,165,233,0.2), rgba(29,78,216,0.25));
        animation: waterBase  var(--flow-speed-base, 12s) linear infinite;
        pointer-events: none;
      }
      @keyframes waterBase {
        0%   { background-position: 0 0, 0 0; }
        100% { background-position: 280px 0, -200px 0; }
      }
      .water-ripple {
        position: absolute; inset: 0;
        background-image:
          repeating-linear-gradient(120deg, rgba(255,255,255,0.06) 0px, rgba(255,255,255,0.06) 2px, rgba(0,0,0,0.04) 4px, rgba(0,0,0,0.02) 6px);
        background-size: 240px 100%;
        mix-blend-mode: overlay; opacity: 0.16;
        animation: waterDrift var(--flow-speed-texture, 10s) linear infinite reverse;
        pointer-events: none;
      }
      .ripple {
        position: absolute;
        width: 14px; height: 14px; border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.85);
        pointer-events: none;
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.25));
        animation: rippleExpand 900ms ease-out forwards;
      }
      .ripple::before, .ripple::after {
        content: "";
        position: absolute; left: 50%; top: 50%;
        width: 100%; height: 100%; border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.55);
        transform: translate(-50%, -50%) scale(0.2);
        animation: rippleExpand 900ms ease-out forwards;
      }
      .ripple::after {
        border-color: rgba(255,255,255,0.35);
        animation-delay: 120ms;
      }
      @keyframes rippleExpand {
        0%   { transform: translate(-50%, -50%) scale(0.2); opacity: 0.9; }
        70%  { opacity: 0.4; }
        100% { transform: translate(-50%, -50%) scale(1.6); opacity: 0; }
      }
      .ring {
        position: absolute; width: 14px; height: 14px; border-radius: 50%;
        border: 3px solid rgba(255,255,255,0.9); opacity: 0.9; pointer-events: none;
        transform: translate(-50%, -50%) scale(0.2);
        animation: ringExpand 1.1s ease-out forwards;
      }
      @keyframes ringExpand {
        0%   { transform: translate(-50%, -50%) scale(0.2); opacity: 0.9; }
        100% { transform: translate(-50%, -50%) scale(var(--ring-scale, 1.4)); opacity: 0; }
      }
      .drop {
        position: absolute; width: 8px; height: 8px; border-radius: 50%;
        background: radial-gradient(circle, #fff 0%, #bfefff 60%, rgba(255,255,255,0.0) 100%);
        transform: translate(-50%, -50%);
        animation: dropMotion 1.1s ease-out forwards;
      }
      @keyframes dropMotion {
        0%   { transform: translate(calc(-50% + 0px), calc(-50% + 0px)); opacity: 1; }
        40%  { transform: translate(calc(-50% + var(--dx, 0px)), calc(-50% - var(--rise, 80px))); opacity: 1; }
        100% { transform: translate(calc(-50% + var(--dx, 0px)), calc(-50% + 0px)); opacity: 0; }
      }
      .foam {
        position: absolute; border-radius: 50%; background: rgba(255,255,255,0.85);
        animation: foamFade 600ms ease-out forwards;
      }
      @keyframes foamFade {
        0%   { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.4); }
      }
      .gaps { display: flex; gap: 24px; align-items: center; justify-content: center; padding: 16px; position: relative; flex-wrap: wrap; }
      .gaps.wide { gap: 40px; }
      .gap { width: var(--gap-width); height: var(--gap-height); background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.1)),
        linear-gradient(90deg, var(--metal1), var(--metal2) 40%, var(--metal3)),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 2px, rgba(0,0,0,0.04) 3px);
        border: 2px solid #7b8792; border-radius: 12px; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center;
        box-shadow: inset 0 0 12px rgba(0,0,0,0.45), 0 10px 24px rgba(0,0,0,0.35);
        overflow: visible;
      }
      .gap.gap-4 { width: var(--gap4-width); }
      .gap::after {
        content: ""; position: absolute; inset: 0; border-radius: 12px;
        box-shadow: inset 0 0 18px rgba(255,255,255,0.06);
      }
      .gap .target { position: absolute; top: -36px; font-size: var(--font-target); font-weight: 900;
        background: linear-gradient(180deg, #0c1628, #071221); color: #bfefff;
        border: 2px solid #1f3b5a; border-radius: 10px; padding: 4px 10px;
        box-shadow: 0 6px 14px rgba(0,0,0,0.45), inset 0 0 8px rgba(46, 225, 255, 0.25);
        text-shadow: 0 0 6px rgba(46, 225, 255, 0.35);
      }
      .slots { display: flex; gap: var(--slot-margin); }
      .slots.expr { align-items: center; }
      .slots.expr.tight { gap: var(--slot-margin); }
      .op { font-weight: 900; color: #bfefff; text-shadow: 0 0 6px rgba(46, 225, 255, 0.35); font-size: var(--font-plank); }
      .eq { margin-left: 4px; margin-right: 4px; font-weight: 900; color: #bfefff; font-size: var(--font-plank); }
      .slot { width: var(--slot-size); height: var(--slot-size); border-radius: 12px; border: 2px solid #7b8792; display: flex; align-items: center; justify-content: center; position: relative;
        background:
          linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.1)),
          linear-gradient(90deg, var(--metal1), var(--metal2) 45%, var(--metal3)),
          repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 2px, rgba(0,0,0,0.04) 3px);
        box-shadow: inset 0 0 12px rgba(0,0,0,0.45);
        color: #f3f7fb;
      }
      .slots.expr.tight .slot { width: var(--slot-size); height: var(--slot-size); }
      .slots.expr.tight .slot::before, .slots.expr.tight .slot::after { width: 4px; }
      .slots.expr.tight .slot::before { left: 4px; }
      .slots.expr.tight .slot::after { right: 4px; }
      .slot::before, .slot::after {
        content: ""; position: absolute; top: 10px; bottom: 10px; width: 8px; border-radius: 2px;
        background: linear-gradient(180deg, #9099a2, #707883);
        box-shadow: inset 0 2px 4px rgba(255,255,255,0.15), inset 0 -2px 4px rgba(0,0,0,0.15);
      }
      .slot::before { left: -10px; }
      .slot::after { right: -10px; }
      .slot.highlight::after {
        box-shadow: 0 0 0 2px rgba(61,219,242,0.6);
      }
      .slot.highlight::before {
        box-shadow: 0 0 0 2px rgba(61,219,242,0.6);
      }
      .slot.highlight {
        outline: 2px dashed rgba(61,219,242,0.35);
      }
      .slot.filled { border-color: #88939e; box-shadow: inset 0 0 14px rgba(0,0,0,0.5); }
      .slot.highlight { border-color: var(--accent); box-shadow: 0 0 12px var(--accent); }
      .bank { display: flex; gap: var(--slot-margin); flex-wrap: wrap; justify-content: center; padding: 16px; background: linear-gradient(180deg, #121a29, #0f172a); border-top: 1px solid #1f2937; }
      .plank { width: var(--plank-size); height: var(--plank-size); border-radius: 16px; border: 2px solid #7b8792; display: flex; align-items: center; justify-content: center; font-size: var(--font-plank); font-weight: 900; position: relative; touch-action: none;
        color: #0c1a26; text-shadow: 0 1px 0 rgba(255,255,255,0.6);
        background-image:
          linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.08)),
          linear-gradient(90deg, var(--metal1), var(--metal2) 45%, var(--metal3)),
          repeating-linear-gradient(0deg, rgba(255,255,255,0.06) 0px, rgba(255,255,255,0.06) 2px, rgba(0,0,0,0.06) 3px),
          radial-gradient(circle at var(--rivet-size) var(--rivet-size), #fff 0%, #d9d9d9 30%, #666 70%, #333 100%),
          radial-gradient(circle at calc(100% - var(--rivet-size)) var(--rivet-size), #fff 0%, #d9d9d9 30%, #666 70%, #333 100%),
          radial-gradient(circle at var(--rivet-size) calc(100% - var(--rivet-size)), #fff 0%, #d9d9d9 30%, #666 70%, #333 100%),
          radial-gradient(circle at calc(100% - var(--rivet-size)) calc(100% - var(--rivet-size)), #fff 0%, #d9d9d9 30%, #666 70%, #333 100%);
        background-size:
          auto, auto, auto,
          var(--rivet-size) var(--rivet-size), var(--rivet-size) var(--rivet-size), var(--rivet-size) var(--rivet-size), var(--rivet-size) var(--rivet-size);
        background-repeat: no-repeat;
        box-shadow: inset 0 0 14px rgba(0,0,0,0.45), 0 10px 24px rgba(0,0,0,0.35);
        user-select: none;
      }
      .plank.dragging {
        box-shadow: inset 0 0 18px rgba(0,0,0,0.55), 0 12px 28px rgba(0,0,0,0.45);
      }
      .plank.dragging::before {
        content: ""; position: absolute; inset: 0; border-radius: 16px;
        background: linear-gradient(135deg, rgba(255,255,255,0.0) 40%, rgba(255,255,255,0.35) 50%, rgba(255,255,255,0.0) 60%);
        animation: shineSweep var(--shine-duration, 1.2s) linear infinite;
      }
      @keyframes shineSweep {
        0% { transform: translateX(-40%); }
        100% { transform: translateX(40%); }
      }
      .plank.dragging { transform: scale(1.08); box-shadow: 0 10px 24px rgba(0,0,0,0.4); }
      .feedback { position: absolute; top: 12px; right: 12px; padding: 6px 10px; border-radius: 8px; background: rgba(0,0,0,0.4); }
      .success { color: var(--good); }
      .fail { color: var(--bad); }
      .controls-bar { display: flex; gap: 12px; align-items: center; }
      .btn { padding: 6px 10px; border: 0; border-radius: 8px; background: var(--accent); color: #042f2e; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.35); }
      .btn.secondary { background: #64748b; color: #0f172a; }
      .role { position: absolute; left: 24px; bottom: 24px; width: 48px; height: 48px; background: linear-gradient(180deg, #ffeb99, #ffd34d); border-radius: 12px; box-shadow: 0 6px 10px rgba(0,0,0,0.35); transition: transform 0.3s ease; }
      .role.move { transform: translateX(240px); }
      .gap .rope-svg { position: absolute; inset: 0; pointer-events: none; }
      .spark {
        position: absolute; width: 6px; height: 6px; border-radius: 50%;
        background: radial-gradient(circle, #fff 0%, #ffd34d 60%, rgba(255,211,77,0.0) 100%);
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.25));
        animation: sparkFly 500ms ease-out forwards;
      }
      @keyframes sparkFly {
        0% { transform: translate(0,0) scale(0.6); opacity: 1; }
        100% { transform: translate(var(--dx, 30px), var(--dy, -30px)) scale(0.2); opacity: 0; }
      }
      @media (max-width: 800px) {
        .gaps { flex-direction: column; }
        .gap { width: 90%; }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      (function () {
        // 严格限制只在本地文件协议下运行
        // 在 Vercel 等服务器环境，依靠 React 运行
        if (location.protocol !== 'file:') return

        // 如果是本地文件协议，或者 React 尚未加载（针对不支持 Module 的环境），则运行此备份脚本
        // 这确保了用户在没有 Node 环境时也能双击 index.html 运行
        if (window.__NBB_RAN__) return
        
        // 简单的环境检测
        const isLocal = location.protocol === 'file:'
        if (!isLocal) {
            // 在服务器上，我们希望优先等待 React 加载
            // 设置一个超时，如果 React 1秒内没反应，再加载备份
            // 但为了简单，我们假设如果支持 module 就会加载 main.tsx
            // 这里不做处理，让两者竞争（React 通常会覆盖）
            // 在 Vercel 上，我们不运行这个备份脚本，以防冲突
            return
        }

        const root = document.getElementById('root')
        // const css = document.createElement('link')
        // css.rel = 'stylesheet'
        // css.href = './src/ui/styles.css'
        // document.head.appendChild(css)

        const state = {
          levelId: 1,
          gaps: [],
          currentGapIndex: 0,
          bank: [],
          errorsCount: 0,
          usedHints: 0,
          status: 'PLAYING',
          tipText: '',
          roleStep: 0,
          startAt: Date.now(),
          mode: null,
        }

        const MODE_CONFIG = {
          SUM2: { requiredCount: 2, operators: ['+'], label: '两块相加（a+b）' },
          ADD2_SUB2: { requiredCount: 4, operators: ['+','-','-'], label: '四块加减（a+b−c−d）' }
        }

        try {
          const s = localStorage.getItem('number-bridge-settings')
          if (s) {
            const parsed = JSON.parse(s)
            if (parsed.mode && MODE_CONFIG[parsed.mode]) state.mode = parsed.mode
          }
        } catch (e) {}

        function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]] } return a }
        
        function beep(freq = 800, ms = 120, type = 'sine') {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)()
            const osc = ctx.createOscillator()
            const gain = ctx.createGain()
            osc.type = type
            osc.frequency.value = freq
            osc.connect(gain)
            gain.connect(ctx.destination)
            gain.gain.setValueAtTime(0.001, ctx.currentTime)
            gain.gain.exponentialRampToValueAtTime(0.1, ctx.currentTime + 0.02)
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + ms / 1000)
            osc.start()
            setTimeout(() => { osc.stop(); ctx.close() }, ms + 20)
          } catch(e) {}
        }

        function evaluateGap(mode, values, target) {
          const cfg = MODE_CONFIG[mode]
          let result = values[0] || 0
          for (let i = 0; i < cfg.operators.length; i++) {
            const op = cfg.operators[i]
            const v = values[i + 1] || 0
            if (op === '+') result += v
            else if (op === '-') result -= v
          }
          const ready = values.length === cfg.requiredCount
          return { result, diff: target - result, ready }
        }

        function genGap(difficulty = 'A', mode = 'SUM2') {
          const target = difficulty === 'A' ? randInt(5, 10) : difficulty === 'B' ? randInt(10, 20) : randInt(20, 100)
          let base = []
          
          if (mode === 'SUM2') {
            const a = randInt(1, Math.floor(target / 2))
            const b = target - a
            base = [a, b]
          } else {
            // Fix infinite loop logic for 4 planks
            let t = target
            let c = randInt(1, Math.floor(t / 2))
            let d = randInt(1, Math.floor(t / 2))
            let sumNeeded = t + c + d
            // Ensure sumNeeded is large enough to be split
            let a = randInt(Math.max(1, Math.floor(sumNeeded / 3)), Math.floor(sumNeeded / 2))
            let b = sumNeeded - a
            base = [a, b, c, d]
          }

          const noise = []
          const n = difficulty === 'C' ? 10 : 8
          const upper = Math.max(target + 30, 40)
          
          for (let i = 0; i < n; i++) {
            let v = randInt(1, upper)
            if (base.some(x => Math.abs(v - x) <= 2)) v += randInt(3, 5)
            noise.push(v)
          }
          
          const bank = shuffle([...base, ...noise]).map((v, i) => ({ id: 'p' + i + '_' + Date.now(), value: v }))
          const required = MODE_CONFIG[mode].requiredCount
          return { id: 'gap_' + Math.random().toString(36).slice(2), target, slots: Array(required).fill(null), bank }
        }

        function genLevel() {
          const m = state.mode || 'SUM2'
          const gaps = m === 'ADD2_SUB2'
            ? [genGap('A', m), genGap('B', m)]
            : [genGap('A', m), genGap('A', m), genGap('B', m)]
          state.gaps = gaps
          state.bank = gaps[0].bank.slice()
          state.currentGapIndex = 0
          state.errorsCount = 0
          state.usedHints = 0
          state.roleStep = 0
          state.status = 'PLAYING'
          state.tipText = ''
          state.startAt = Date.now()
        }

        function renderSelector() {
          root.innerHTML = `
            <div style="padding:24px; display:flex; gap:24px; justify-content:center; flex-wrap:wrap; margin-top: 40px;">
              <button class="mode-card" id="modeSum2" title="${MODE_CONFIG.SUM2.label}">
                <div class="mode-title">${MODE_CONFIG.SUM2.label}</div>
                <div class="mode-illustration">
                  <div class="mode-slot">+</div>
                  <div class="mode-eq">= T</div>
                </div>
              </button>
              <button class="mode-card" id="modeAdd2Sub2" title="${MODE_CONFIG.ADD2_SUB2.label}">
                <div class="mode-title">${MODE_CONFIG.ADD2_SUB2.label}</div>
                <div class="mode-illustration">
                  <div class="mode-slot">+</div><div class="mode-slot">-</div><div class="mode-slot">-</div>
                  <div class="mode-eq">= T</div>
                </div>
              </button>
            </div>
          `
          document.getElementById('modeSum2').onclick = () => {
            state.mode = 'SUM2'
            saveMode()
            genLevel()
            render()
          }
          document.getElementById('modeAdd2Sub2').onclick = () => {
            state.mode = 'ADD2_SUB2'
            saveMode()
            genLevel()
            render()
          }
        }
        
        function saveMode() {
            try {
              const s = localStorage.getItem('number-bridge-settings')
              const parsed = s ? JSON.parse(s) : {}
              parsed.mode = state.mode
              localStorage.setItem('number-bridge-settings', JSON.stringify(parsed))
            } catch (e) {}
        }

        function render() {
          if (!state.mode) { renderSelector(); return }
          
          const elapsed = Math.floor((Date.now() - state.startAt) / 1000)
          const gap = state.gaps[state.currentGapIndex]
          const vals = gap.slots.filter(Boolean).map(p => p.value)
          const evalRes = evaluateGap(state.mode, vals, gap.target)
          const remaining = evalRes.diff

          root.innerHTML = `
            <div class="game">
              <div class="hud">
                <div>Level ${state.levelId} · Gap ${state.currentGapIndex + 1}/${state.gaps.length}</div>
                <div>Errors ${state.errorsCount}</div>
                <div>Time ${elapsed}s</div>
                <div class="controls-bar">
                  <button class="btn secondary" id="btnChooseMode">选择玩法</button>
                  <button class="btn" id="btnHint">提示</button>
                  <button class="btn secondary" id="btnReset">重来</button>
                </div>
                <div class="feedback">${state.tipText || (vals.length ? '当前值 ' + evalRes.result + '，还差 ' + remaining : '把桥板拖到槽位上')}</div>
              </div>
              <div class="river">
                <div class="role ${state.roleStep ? 'move' : ''}"></div>
                <div class="gaps ${state.mode === 'ADD2_SUB2' ? 'wide' : ''}">
                  ${state.gaps.map((g, i) => `
                    <div id="${g.id}" class="gap ${g.slots.length > 3 ? 'gap-4' : ''}" style="opacity:${i < state.currentGapIndex ? 0.5 : 1}">
                      <div class="target">${g.target}</div>
                      <svg class="rope-svg" viewBox="0 0 220 140" preserveAspectRatio="none" style="position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0;">
                         <defs>
                           <linearGradient id="sb_${i}" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#bfc6cd"/><stop offset="100%" stop-color="#88939e"/></linearGradient>
                         </defs>
                         <!-- 简化版 SVG 渲染，为了本地运行不依赖复杂组件 -->
                      </svg>
                      <div class="slots expr ${MODE_CONFIG[state.mode].requiredCount > 3 ? 'tight' : ''}" style="z-index:1">
                        ${g.slots.map((p, si) => `
                          <div class="slot ${p ? 'filled' : ''} ${i === state.currentGapIndex ? 'highlight' : ''}" data-si="${si}" data-gi="${i}">${p ? p.value : ''}</div>
                          ${si < MODE_CONFIG[state.mode].operators.length ? `<div class="op">${MODE_CONFIG[state.mode].operators[si]}</div>` : ''}
                        `).join('')}
                        <div class="eq">=</div>
                        <div class="mode-eq">T</div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
              <div class="bank">
                ${state.bank.map((p, i) => `
                  <div class="plank" data-idx="${i}" style="touch-action: none;">${p.value}</div>
                `).join('')}
              </div>
            </div>
          `
          bindEvents()
        }

        function checkGap() {
          const gap = state.gaps[state.currentGapIndex]
          const filled = gap.slots.filter(Boolean)
          if (filled.length < gap.slots.length) return
          
          state.status = 'CHECKING'
          const vals = filled.map(p => p.value)
          const evalRes = evaluateGap(state.mode, vals, gap.target)
          
          if (evalRes.ready && evalRes.diff === 0) {
            beep(900, 120, 'triangle')
            state.roleStep++
            
            // 水花特效
            try {
                const river = document.querySelector('.river')
                const gapEl = document.getElementById(gap.id)
                if (river && gapEl) {
                  const rr = river.getBoundingClientRect()
                  const gr = gapEl.getBoundingClientRect()
                  const x = gr.left + gr.width / 2 - rr.left
                  const y = gr.bottom - rr.top + 6
                  const el = document.createElement('div')
                  el.className = 'ripple'
                  el.style.left = x + 'px'
                  el.style.top = y + 'px'
                  river.appendChild(el)
                  setTimeout(() => el.remove(), 950)
                }
            } catch(e){}

            const gapEl = document.getElementById(gap.id)
            if (gapEl) gapEl.classList.add('success')

            setTimeout(() => {
              if (gapEl) gapEl.classList.remove('success')
              if (state.currentGapIndex === state.gaps.length - 1) {
                // 通关！
                state.levelId++
                genLevel()
                render()
              } else {
                state.currentGapIndex++
                const next = state.gaps[state.currentGapIndex]
                state.bank = next.bank.slice()
                state.status = 'PLAYING'
                render()
              }
            }, 1000)
          } else {
            beep(180, 180, 'sawtooth')
            state.errorsCount++
            const gapEl = document.getElementById(gap.id)
            if (gapEl) {
              gapEl.classList.add('fail')
              setTimeout(() => gapEl.classList.remove('fail'), 500)
            }
            // 退回桥板
            for (let i = 0; i < gap.slots.length; i++) {
              const p = gap.slots[i]
              if (p) { state.bank.push(p); gap.slots[i] = null }
            }
            state.status = 'PLAYING'
            render()
          }
        }

        let dragging = null
        let dragOffset = {x:0, y:0}

        function bindEvents() {
          document.getElementById('btnReset').onclick = () => { genLevel(); render() }
          document.getElementById('btnChooseMode').onclick = () => {
            state.mode = null
            renderSelector()
          }
          
          // Hint Logic
          document.getElementById('btnHint').onclick = () => {
            const gap = state.gaps[state.currentGapIndex]
            const filledCount = gap.slots.filter(Boolean).length
            const cfg = MODE_CONFIG[state.mode]
            if (filledCount >= cfg.requiredCount) return
            
            const nextOp = cfg.operators[filledCount] || '+'
            let bestIdx = -1, bestScore = Infinity
            
            for (let i = 0; i < state.bank.length; i++) {
              const vals = gap.slots.filter(Boolean).map(p => p.value)
              const v = state.bank[i].value
              const testVals = vals.slice()
              if (filledCount === 0) testVals.push(v)
              else {
                const interim = evaluateGap(state.mode, vals, gap.target).result
                const resultPreview = nextOp === '+' ? interim + v : interim - v
                const diffPreview = Math.abs(gap.target - resultPreview)
                if (diffPreview < bestScore) { bestScore = diffPreview; bestIdx = i }
                continue
              }
              const diffPreview = Math.abs(evaluateGap(state.mode, testVals, gap.target).diff)
              if (diffPreview < bestScore) { bestScore = diffPreview; bestIdx = i }
            }
            
            const els = document.querySelectorAll('.plank')
            if (bestIdx !== -1 && els[bestIdx]) {
              els[bestIdx].style.boxShadow = '0 0 18px #10b981'
              setTimeout(() => els[bestIdx].style.boxShadow = '', 600)
            }
          }

          // Drag and Drop
          document.querySelectorAll('.plank').forEach(el => {
            el.onpointerdown = (e) => {
              const idx = +el.dataset.idx
              const p = state.bank[idx]
              const rect = el.getBoundingClientRect()
              dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top }
              
              dragging = { idx, p, el }
              el.classList.add('dragging')
              el.setPointerCapture(e.pointerId)
              beep(700, 80, 'square')
            }
          })

          document.onpointermove = (e) => {
            if (!dragging) return
            e.preventDefault()
            const x = e.clientX - dragOffset.x
            const y = e.clientY - dragOffset.y
            dragging.el.style.position = 'fixed'
            dragging.el.style.left = x + 'px'
            dragging.el.style.top = y + 'px'
            dragging.el.style.zIndex = 100
          }

          document.onpointerup = (e) => {
            if (!dragging) return
            dragging.el.classList.remove('dragging')
            dragging.el.style.position = ''
            dragging.el.style.left = ''
            dragging.el.style.top = ''
            dragging.el.style.zIndex = ''
            
            const gap = state.gaps[state.currentGapIndex]
            const gapEl = document.getElementById(gap.id)
            if (gapEl) {
                const rect = gapEl.getBoundingClientRect()
                if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                  const slotIdx = gap.slots.findIndex(s => s === null)
                  if (slotIdx !== -1) {
                    gap.slots[slotIdx] = dragging.p
                    state.bank.splice(dragging.idx, 1)
                    render()
                    checkGap()
                  }
                }
            }
            dragging = null
          }
        }

        // Start
        if (!state.mode) renderSelector()
        else { genLevel(); render() }
      })()
    </script>
  </body>
</html>